Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'class methods' stamp: '4 12/19/2018 16:05'!ambiguities! !!MyObject class methodsFor: 'class methods' stamp: 'YH 12/24/2018 20:42'!behavesLike | behavesSet currentClass |behavesSet := Set new.(self isInterface)	ifTrue: [		behavesSet add: self.		].behavesSet addAll: (self instVarNamed: 'behavesLike').currentClass := self.[(currentClass ~= MyObject)] whileTrue:  [		currentClass := currentClass superclass.		behavesSet addAll: currentClass behavesLike.	].^behavesSet.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/25/2018 11:21'!compile: aSourceCode where: anOrderedCollection| s stream reg1 reg2 sFirstLine sSecLine sSecLine2 sInjected sCode args typeCheck abstract |stream := aSourceCode readStream.sFirstLine := String new.sFirstLine := stream nextLine. "first line - function name+ parameters"sSecLine := String new.sSecLine := stream nextLine. "second line - maybe local variables maybe firstline of code - and maybe EMPTY!!"abstract:= (self isAbstract: aSourceCode).((self isInterface) and:[abstract = false])"trying to compile not an abstract method to an Interface!!"	ifTrue:[AssertionFailure signal: 'Interfaces are not allowed to have methods that define behavior!!']."creating the local variables line"sSecLine2 := String new.reg1:= '.*\|.*' asRegex.((abstract == false) and:[reg1 matches: sSecLine]) "we already have local vars or abstract method"	ifTrue: [		sSecLine2 := '|', (sSecLine copyWithout: $| ), ' index currentClass |'.		sCode := (stream nextLine),Character cr.		[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]	ifFalse: [sSecLine2 := '| args restricts index currentClass |'.			(abstract == false) ifTrue: [sCode := sSecLine].			[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]."getting the args from the function parameters"args := OrderedCollection new.reg1:= '\:(\s)*(\w)+' .reg2 := '\w+' .sFirstLine copyWithRegex: reg1 matchesTranslatedUsing: [:match |	match copyWithRegex: reg2 matchesTranslatedUsing: [:arg | args add: arg]]."check the size of the restriction and the arguments given"	(args size == anOrderedCollection size) 	ifFalse:[AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!']."here we know the sizes are equal"typeCheck := String new.typeCheck := '((true) '.(args size >= 1)ifTrue: [	((anOrderedCollection at:1) asString = 'nil')	ifFalse: [	typeCheck :=typeCheck, 'and:[currentClass:=''',(anOrderedCollection at:1),'''. ',(args at:1),' isKindOf: (',(anOrderedCollection at:1),')] '.]]. "first"2 to: (args size) do:	[:i | 			((anOrderedCollection at:i) asString = 'nil')			ifTrue: [typeCheck :=typeCheck, 'and:[index:= index+1. true] ']			ifFalse: [			typeCheck := typeCheck,'and:[index:= index+1. currentClass:=''',(anOrderedCollection at:i) ,'''. ',			(args at:i),' isKindOf: (',(anOrderedCollection at:i),')] '].].typeCheck := typeCheck,')',Character cr."now typeCheck is ((XXX) and:[XXX]"s:= String new.sInjected:= String new."creating injected code for checking"sInjected := 'index := 1.',Character cr.sInjected := sInjected, 'currentClass := String new.',Character cr.sInjected := sInjected,typeCheck,						'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument '', (index asString) , '' should be '', currentClass ].'.s:= sFirstLine,Character cr, sSecLine2,Character cr,	sInjected ,Character cr.	(abstract == false) ifTrue: [s:=s,sCode].	"Transcript show: s. REMOVEE!!!!!!"self compile: s.! !!MyObject class methodsFor: 'class methods' stamp: 'YH 12/24/2018 21:37'!isImplemented| subClasses isImplemented found  |(self isInterface)ifFalse:[AssertionFailure signal: (self class name) asString, ' is not an interface!!'].subClasses := Set new.isImplemented:= false.found:= true.subClasses:= MyObject allSubclasses.subClasses do: [:subClass | (((subClass behavesLike) includes: self) and: [(subClass isInterface) not])				ifTrue: [ "subclass behaves like given Interface"					(self methodDict size = 0)						ifTrue: [isImplemented:=true].					self methodDictionary keys do: [:method | 						(found and: [(subClass canUnderstand: method ) not]) 							ifTrue:[found := false]. "subclass doesnt understand this interface methods so go out!!"									].					(found)					ifTrue: [isImplemented:=true].					 ].			].^isImplemented.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 20:53'!isInterface	^isInterface.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/24/2018 11:11'!new(self isInterface)	 ifTrue:[AssertionFailure signal: 'Interfaces can not be instantiated!!'].^ self basicNew initialize.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 23:52'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNam| newClass |newClass :=(ClassBuilder new)		superclass: self		subclass: aSubclassName		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries		category: aCategoryNam.		newClass instVarNamed: 'isInterface' put: false.newClass instVarNamed: 'behavesLike' put: (self behavesLike).^newClass.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 23:39'!subclass: aSubclassName isInterface: isInterface behavesLike:aCollection instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryNa| newClass |(isInterface and:[(self class)asString ~= 'MyObject class']) 	ifTrue:[AssertionFailure signal: 'Interfaces must derive from MyObject!!'].	"'Interfaces can not have state!!'"(isInterface and:[instVarNames ~= '']) 	ifTrue:[AssertionFailure signal: 'Interfaces can not have state!!'].(isInterface == false and:[self isInterface])	ifTrue:[AssertionFailure signal: 'Classes can not derive from an interface!!'].aCollection do: [:c | (c isInterface) ifFalse:[AssertionFailure signal:'Can not behave like a non-interface!!'] ].newClass := self subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNa."newClass addInstanceVarNamed: 'isInterface' withValue: isInterface.aSubclassName  addInstanceVarNamed: 'behavesLike' withValue: aCollection."newClass instVarNamed: 'isInterface' put: isInterface.newClass instVarNamed: 'behavesLike' put: aCollection.^newClass.! !!MyObject class methodsFor: 'Aux' stamp: '4 12/25/2018 11:13'!isAbstract: code| stream line1 line2 |stream := code readStream.line1 := String new.line2 := String new.line1 := stream nextLine. "first line - function name+ parameters"line2 := stream nextLine. "first line - function name+ parameters"(line2 = nil)	ifTrue:[^true].^false.! !MyObject subclass: #A	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!IA methodsFor: 'as yet unclassified' stamp: '4 12/25/2018 11:23'!foo: a| args restricts index currentClass |index := 1.currentClass := String new.((true) and:[currentClass:='Integer'. a isKindOf: (Integer)] )ifFalse: [AssertionFailure signal: 'Type mismatch!! Argument ', (index asString) , ' should be ', currentClass ].! !