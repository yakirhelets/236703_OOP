Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'codeCompiler' stamp: '4 12/19/2018 15:35'!compile: aSourceCode where: anOrderedCollection| s stream reg1 reg2 sFirstLine sSecLine sSecLine2 sInjected sCode args typeCheck abstract |stream := aSourceCode readStream.sFirstLine := String new.sFirstLine := stream nextLine. "first line - function name+ parameters"sSecLine := String new.sSecLine := stream nextLine. "second line - maybe local variables maybe firstline of code - and maybe EMPTY!!"abstract:=false.(sSecLine == nil) ifTrue: [abstract:= true]."creating the local variables line"sSecLine2 := String new.reg1:= '.*\|.*' asRegex.((abstract == false) and:[reg1 matches: sSecLine]) "we already have local vars or abstract method"	ifTrue: [		sSecLine2 := '|', (sSecLine copyWithout: $| ), ' index currentClass |'.		sCode := (stream nextLine),Character cr.		[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]	ifFalse: [sSecLine2 := '| args restricts index currentClass |'.			(abstract == false) ifTrue: [sCode := sSecLine].			[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]."getting the args from the function parameters"args := OrderedCollection new.reg1:= '\:(\s)*(\w)+' .reg2 := '\w+' .sFirstLine copyWithRegex: reg1 matchesTranslatedUsing: [:match |	match copyWithRegex: reg2 matchesTranslatedUsing: [:arg | args add: arg]]."check the size of the restriction and the arguments given"	(args size == anOrderedCollection size) 	ifFalse:[AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!']."here we know the sizes are equal"typeCheck := String new.typeCheck := '((true) '.(args size >= 1)ifTrue: [	((anOrderedCollection at:1) asString = 'nil')	ifFalse: [	typeCheck :=typeCheck, 'and:[currentClass:=''',(anOrderedCollection at:1),'''. ',(args at:1),' isKindOf: (',(anOrderedCollection at:1),')] '.]]. "first"2 to: (args size) do:	[:i | 			((anOrderedCollection at:i) asString = 'nil')			ifTrue: [typeCheck :=typeCheck, 'and:[index:= index+1. true] ']			ifFalse: [			typeCheck := typeCheck,'and:[index:= index+1. currentClass:=''',(anOrderedCollection at:i) ,'''. ',			(args at:i),' isKindOf: (',(anOrderedCollection at:i),')] '].].typeCheck := typeCheck,')',Character cr."now typeCheck is ((XXX) and:[XXX]"s:= String new.sInjected:= String new."creating injected code for checking"sInjected := 'index := 1.',Character cr.sInjected := sInjected, 'currentClass := String new.',Character cr.sInjected := sInjected,typeCheck,						'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument '', (index asString) , '' should be '', currentClass ].'.s:= sFirstLine,Character cr, sSecLine2,Character cr,	sInjected ,Character cr.	(abstract == false) ifTrue: [s:=s,sCode].	"Transcript show: s. REMOVEE!!!!!!"self class compile: s.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'class methods' stamp: '4 12/19/2018 16:05'!ambiguities! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 20:25'!behavesLike | behavesSet currentClass |behavesSet := Set new.behavesSet addAll: behavesLike.currentClass := self.[(currentClass class ~= MyObject)] whileTrue:  [		currentClass := currentClass superclass.		behavesSet addAll: currentClass behavesLike.	].^behavesSet.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 21:15'!isImplemented| subClasses isImplemented found  |(self isInterface)ifFalse:[AssertionFailure signal: (self class name) asString, ' is not an interface!!'].subClasses := Set new.isImplemented:= false.found:= false.subClasses:= self allSubClasses.subClasses do: [:subClass | ((subClass behavesLike) include: (self class))				ifTrue: [ "subclass behaves like given Interface"					self methodsDo: [:method | 						(subClass doesNotUnderstand: method ) 							ifTrue:[^true]. "subclass doesnt understand this interface methods so go out!!"						isImplemented:=true.									].					 ].			].^isImplemented.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 20:53'!isInterface	^isInterface.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 20:16'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNam| newClass |newClass := self subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNam.newClass instVarNamed: (isInterface asString) put: false.newClass instVarNamed: (behavesLike asString) put: (self behavesLike).^newClass.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 21:40'!subclass: aSubclassName isInterface: isInterface behavesLike:aCollection instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryNa| newClass |(isInterface and:[(self class)asString ~= 'MyObject class']) 	ifTrue:[AssertionFailure signal: 'Interfaces must derive from MyObject!!'].	"'Interfaces can not have state!!'"(isInterface and:[instVarNames ~= '']) 	ifTrue:[AssertionFailure signal: 'Interfaces can not have state!!'].(isInterface == false and:[self superclass isInterface])	ifTrue:[AssertionFailure signal: 'Classes can not derive from an interface!!'].aCollection do: [:c | (c isInterface) ifFalse:[AssertionFailure signal:'Can not behave like a non-interface!!'] ].newClass := self subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNa."newClass addInstanceVarNamed: 'isInterface' withValue: isInterface.newClass addInstanceVarNamed: 'behavesLike' withValue: aCollection."newClass instVarNamed: (isInterface asString) put: isInterface.newClass instVarNamed: (behavesLike asString) put: aCollection.^newClass.! !