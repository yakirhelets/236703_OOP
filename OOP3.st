Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'as yet unclassified' stamp: '4 12/26/2018 14:09'!isKindOf: aClassOrInterface 	| value1 value2 |	value1 := ((self class ==  aClassOrInterface) or: [ self class inheritsFrom: aClassOrInterface ]).	value2:= ((self class behavesLike) includes: aClassOrInterface).^(value1 or:[value2 ]).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 16:53'!ambiguities| sCollection bSet mSet   |sCollection := Set new.bSet := Set new.mSet := Set new. "all encountered methods by now - check if we have duplications -> we got ambiguity!!"bSet := self behavesLike. "bSet inc all the behaves like of self"bSet do: [:bClass | "for each behaves like class"	"behaves like need to Keep the right order!! TODO!!!!!!"			(bClass behavesLike) do: [:intClass |				(bClass ~= intClass) "me and my follower are interfaces!!"					ifTrue:[ 							mSet addAll: (intClass methodDictionary keys).							sCollection addAll: (intClass methodDictionary keys). "TODO check for dups--------------------------------"						 ].			 ].			 (bClass methodDictionary keys) do: [:method| "check all bClass methods if we encountered them before"				((mSet includes: method) )					ifTrue:[((sCollection includes: method) not ) "if not added yet"							ifTrue: [sCollection add: method]							].				].			mSet addAll: (bClass methodDictionary keys). "we didnt encountered nothing - save for future checks"		].^(sCollection asSortedCollection). "return a SORTED set"! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 14:43'!behavesLike | behavesSet currentClass auxSet |behavesSet := Set new.auxSet := Set new.(self isInterface) "interface behaves like himself"	ifTrue: [		behavesSet add: self.		].behavesSet addAll: (self instVarNamed: 'behavesLike').currentClass := self.[(currentClass ~= MyObject and:[(currentClass isInterface)not])] whileTrue:  [		currentClass := currentClass superclass.		behavesSet addAll: currentClass behavesLike.	].behavesSet do: [:interf |	(self ~= interf) "for every interface different from me"	ifTrue: [		auxSet addAll: interf behavesLike.		]	].behavesSet addAll: auxSet.^behavesSet.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 16:48'!compile: aSourceCode| abstract |abstract:= (self isAbstractFunc: aSourceCode).((self isInterface) and:[abstract = false])"trying to compile not an abstract method to an Interface!!"	ifTrue:[AssertionFailure signal: 'Interfaces are not allowed to have methods that define behavior!!'].^self compile: aSourceCode notifying: nil.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 16:54'!compile: aSourceCode where: anOrderedCollection| s stream reg1 reg2 sFirstLine sSecLine sSecLine2 sInjected sCode args typeCheck abstract |stream := aSourceCode readStream.sFirstLine := String new.sFirstLine := stream nextLine. "first line - function name+ parameters"sSecLine := String new.sSecLine := stream nextLine. "second line - maybe local variables maybe firstline of code - and maybe EMPTY!!"abstract:= (self isAbstractFunc: aSourceCode).((self isInterface) and:[abstract = false])"trying to compile not an abstract method to an Interface!!"	ifTrue:[AssertionFailure signal: 'Interfaces are not allowed to have methods that define behavior!!']."creating the local variables line"sSecLine2 := String new.reg1:= '.*\|.*' asRegex.((abstract == false) and:[reg1 matches: sSecLine]) "we already have local vars or abstract method"	ifTrue: [		sSecLine2 := '|', (sSecLine copyWithout: $| ), ' index currentClass |'.		sCode := (stream nextLine),Character cr.		[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]	ifFalse: [sSecLine2 := '| index currentClass |'.			(abstract == false) ifTrue: [sCode := sSecLine].			[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]."getting the args from the function parameters"args := OrderedCollection new.reg1:= '\:(\s)*(\w)+' .reg2 := '\w+' .sFirstLine copyWithRegex: reg1 matchesTranslatedUsing: [:match |	match copyWithRegex: reg2 matchesTranslatedUsing: [:arg | args add: arg]]."check the size of the restriction and the arguments given"	(args size == anOrderedCollection size) 	ifFalse:[AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!']."here we know the sizes are equal"typeCheck := String new.typeCheck := '((true) '.(args size >= 1)ifTrue: [	((anOrderedCollection at:1) asString = 'nil')	ifFalse: [	typeCheck :=typeCheck, 'and:[currentClass:=''',(anOrderedCollection at:1),'''. ',(args at:1),' isKindOf: (',(anOrderedCollection at:1),')] '.]]. "first"2 to: (args size) do:	[:i | 			((anOrderedCollection at:i) asString = 'nil')			ifTrue: [typeCheck :=typeCheck, 'and:[index:= index+1. true] ']			ifFalse: [			typeCheck := typeCheck,'and:[index:= index+1. currentClass:=''',(anOrderedCollection at:i) ,'''. ',			(args at:i),' isKindOf: (',(anOrderedCollection at:i),')] '].].typeCheck := typeCheck,')',Character cr."now typeCheck is ((XXX) and:[XXX]"s:= String new.sInjected:= String new."creating injected code for checking"sInjected := 'index := 1.',Character cr.sInjected := sInjected, 'currentClass := String new.',Character cr.sInjected := sInjected,typeCheck,						'	ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument '', (index asString) , '' should be '', currentClass ].'.s:= sFirstLine,Character cr, sSecLine2,Character cr,	sInjected ,Character cr.	(abstract == false) ifTrue: [s:=s,sCode].^self compile: s notifying: nil.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 15:42'!isImplemented| subClasses isImplemented found knownMethods  |(self isInterface)	ifFalse:[AssertionFailure signal: (self  asString), ' is not an interface!!'].subClasses := Set new.knownMethods := Set new.isImplemented:= false.subClasses:= (MyObject allSubclasses) asSet.(self behavesLike) do:[:interface | knownMethods addAll: (interface methodDictionary keys) ]. "all known methods from all the behaves like interfaces!!"subClasses do: [:subClass |found:= true. (((subClass behavesLike) includes: self) and: [(subClass isInterface) not])				ifTrue: [ "subclass behaves like given Interface"					(knownMethods size = 0)						ifTrue: [isImplemented:=true].					knownMethods do: [:method | "for each method in self"							(found and: [(subClass canUnderstand: method ) not]) 								ifTrue:[found := false]. "subclass doesnt understand this interface methods so go out!!"										].					(found)						ifTrue: [isImplemented:=true].					 ].			].^isImplemented.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 20:53'!isInterface	^isInterface.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 16:55'!new(self isInterface)	 ifTrue:[AssertionFailure signal: 'Interfaces can not be instantiated!!'].(self behavesLike) do:[:interface | 	(self isAbstractClass) "check if the given class is abstract - if so we CANT create instance!!"		ifTrue:[AssertionFailure signal: 'Can not instantiate an Abstract class!!'].	].^ self basicNew initialize.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 16:35'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNam| newClass |(self isInterface)	ifTrue:[AssertionFailure signal: 'Classes can not derive from an interface!!'].newClass :=(ClassBuilder new)		superclass: self		subclass: aSubclassName		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries		category: aCategoryNam.		newClass instVarNamed: 'isInterface' put: false.newClass instVarNamed: 'behavesLike' put: {}. "(self behavesLike). "^newClass.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 16:56'!subclass: aSubclassName isInterface: isInterface behavesLike:aCollection instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryNa| newClass |(isInterface and:[(self class)asString ~= 'MyObject class']) 	ifTrue:[AssertionFailure signal: 'Interfaces must derive from MyObject!!'].	"'Interfaces can not have state!!'"(isInterface and:[instVarNames ~= '']) 	ifTrue:[AssertionFailure signal: 'Interfaces can not have state!!'].(isInterface == false and:[self isInterface])	ifTrue:[AssertionFailure signal: 'Classes can not derive from an interface!!'].aCollection do: [:c | (c isInterface)	 ifFalse:[AssertionFailure signal:'Can not behave like a non-interface!!'] ].newClass := self subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNa."newClass addInstanceVarNamed: 'isInterface' withValue: isInterface.aSubclassName  addInstanceVarNamed: 'behavesLike' withValue: aCollection."newClass instVarNamed: 'isInterface' put: isInterface.newClass instVarNamed: 'behavesLike' put: (aCollection asSet).^newClass.! !!MyObject class methodsFor: 'Aux' stamp: '4 12/26/2018 17:00'!isAbstractClass| found knownMethods currentClass interfaceMethods |"aux method for checking if there is any interface that the class is behaves Like but do not implement it =abstract"."sanity check"(self isInterface)	ifTrue:[^false].	knownMethods := Set new.currentClass := self.[(currentClass ~= MyObject and:[(currentClass isInterface) not]) ]whileTrue:[ "collecting all known method for the class"	knownMethods addAll: (currentClass methodDictionary keys).	currentClass:= currentClass superclass.].(self behavesLike) do: [:interface |found:= true. 				interfaceMethods := Set new.				"get all interface methods:"				(interface behavesLike) do:[:intBehaveLike | interfaceMethods addAll: (interface methodDictionary keys) ]. 				(interfaceMethods size ~= 0) "there are methods in that interface - lets check if self implements it"				ifTrue: [ 					interfaceMethods do: [:method | "for each method in self"							((self canUnderstand: method ) not) 								ifTrue:[^true]. "there is atleast one interface that the class is not implementing!!"										].					 ].			].^false.! !!MyObject class methodsFor: 'Aux' stamp: '4 12/26/2018 17:00'!isAbstractFunc: code| stream line1 line2 |"aux method for checking if the given function is abstract as defined"stream := code readStream.line1 := String new.line2 := String new.line1 := stream nextLine. "first line - function name+ parameters"line2 := stream nextLine. "first line - function name+ parameters"(line2 = nil)	ifTrue:[^true].^false.! !