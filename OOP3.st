Object subclass: #MyObject	instanceVariableNames: 'behavesLike isInterface'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'codeCompiler' stamp: '4 12/19/2018 15:22'!compile: aSourceCode where: anOrderedCollection| s stream reg1 reg2 sFirstLine sSecLine sSecLine2 sInjected sCode args typeCheck abstract |stream := aSourceCode readStream.sFirstLine := String new.sFirstLine := stream nextLine. "first line - function name+ parameters"sSecLine := String new.sSecLine := stream nextLine. "second line - maybe local variables maybe firstline of code - and maybe EMPTY!!"abstract:=false."deal with EMPTY METHOD!! - XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"(sSecLine == nil) ifTrue: [abstract:= true]."creating the local variables line"sSecLine2 := String new.reg1:= '.*\|.*' asRegex.((abstract == false) and:[reg1 matches: sSecLine]) "we already have local vars or abstract method"	ifTrue: [		sSecLine2 := '|', (sSecLine copyWithout: $| ), ' index currentClass |'.		sCode := (stream nextLine),Character cr.		[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]	ifFalse: [sSecLine2 := '| args restricts index currentClass |'.			(abstract == false) ifTrue: [sCode := sSecLine].			[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]."getting the args from the function parameters"args := OrderedCollection new.reg1:= '\:(\s)*(\w)+' .reg2 := '\w+' .sFirstLine copyWithRegex: reg1 matchesTranslatedUsing: [:match |	match copyWithRegex: reg2 matchesTranslatedUsing: [:arg | args add: arg]]."check the size of the restriction and the arguments given"	(args size == anOrderedCollection size) 	ifFalse:[AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!']."here we know the sizes are equal"typeCheck := String new.typeCheck := '((true) '.(args size >= 1)ifTrue: [	((anOrderedCollection at:1) asString = 'nil')	ifFalse: [	typeCheck :=typeCheck, 'and:[currentClass:=''',(anOrderedCollection at:1),'''. ',(args at:1),' isKindOf: (',(anOrderedCollection at:1),')] '.]]. "first"2 to: (args size) do:	[:i | 			((anOrderedCollection at:i) asString = 'nil')			ifTrue: [typeCheck :=typeCheck, 'and:[index:= index+1. true] ']			ifFalse: [			typeCheck := typeCheck,'and:[index:= index+1. currentClass:=''',(anOrderedCollection at:i) ,'''. ',			(args at:i),' isKindOf: (',(anOrderedCollection at:i),')] '].].typeCheck := typeCheck,')',Character cr."now typeCheck is ((XXX) and:[XXX]"s:= String new.sInjected:= String new."creating injected code for checking"sInjected := 'index := 1.',Character cr.sInjected := sInjected, 'currentClass := String new.',Character cr.sInjected := sInjected,typeCheck,						'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument '', (index asString) , '' should be '', currentClass ].'.s:= sFirstLine,Character cr, sSecLine2,Character cr,	sInjected ,Character cr.	(abstract == false) ifTrue: [s:=s,sCode].	"Transcript show: s. REMOVEE!!!!!!"self class compile: s.! !!MyObject methodsFor: 'codeCompiler' stamp: '4 12/15/2018 12:20'!initialize	behavesLike := Set new.	isInterface := false.! !!MyObject methodsFor: 'methods' stamp: '4 12/15/2018 12:18'!ambiguities! !!MyObject methodsFor: 'methods' stamp: '4 12/15/2018 12:17'!behavesLike	^(behavesLike asSet).! !!MyObject methodsFor: 'methods' stamp: '4 12/15/2018 12:17'!isImplemented! !!MyObject methodsFor: 'methods' stamp: '4 12/15/2018 12:16'!isInterface	^isInterface.! !!MyObject methodsFor: 'methods' stamp: '4 12/15/2018 12:16'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNam! !!MyObject methodsFor: 'methods' stamp: '4 12/15/2018 12:14'!subclass: aSubclassName isInterface: isInterface behavesLike:aCollection instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryNa! !!MyObject methodsFor: 'as yet unclassified' stamp: '4 12/19/2018 15:23'!foo: a bar:b baz: c| var1  index currentClass |index := 1.currentClass := String new.((true) and:[currentClass:='Integer'. a isKindOf: (Integer)] and:[index:= index+1. true] and:[index:= index+1. currentClass:='Number'. c isKindOf: (Number)] )ifFalse: [AssertionFailure signal: 'Type mismatch!! Argument ', (index asString) , ' should be ', currentClass ].var1 := a + c + (2 * b)."just a comment, nothing special"^ (var1 * var1)! !Object subclass: #NameOfSubclass	instanceVariableNames: 'behavesLike isInterface'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!