Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'as yet unclassified' stamp: '4 12/26/2018 14:09'!isKindOf: aClassOrInterface 	| value1 value2 |	value1 := ((self class ==  aClassOrInterface) or: [ self class inheritsFrom: aClassOrInterface ]).	value2:= ((self class behavesLike) includes: aClassOrInterface).^(value1 or:[value2 ]).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'class methods' stamp: '4 12/25/2018 21:55'!ambiguities| sCollection bSet mSet   |sCollection := Set new.bSet := Set new.mSet := Set new. "all encountered methods by now - check if we have duplications -> we got ambiguity!!"bSet := self behavesLike. "bSet inc all the behaves like of self"bSet do: [:bClass | "for each behaves like class"	"behaves like need to Keep the right order!! TODO!!!!!!"			(bClass behavesLike) do: [:intClass |				(bClass ~= intClass) "me and my follower are interfaces!!"					ifTrue:[ 							mSet addAll: (intClass methodDictionary keys).							sCollection addAll: (intClass methodDictionary keys). "TODO check for dups--------------------------------"						 ].			 ].					 (bClass methodDictionary keys) do: [:method| "check all bClass methods if we encountered them before"				((mSet includes: method) )					ifTrue:[((sCollection includes: method) not ) "if not added yet"							ifTrue: [sCollection add: method]							].				].			mSet addAll: (bClass methodDictionary keys). "we didnt encountered nothing - save for future checks"		].^sCollection.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 13:47'!behavesLike | behavesSet currentClass |behavesSet := Set new.(self isInterface) "interface behaves like himself"	ifTrue: [		behavesSet add: self.		].behavesSet addAll: (self instVarNamed: 'behavesLike').currentClass := self.[(currentClass ~= MyObject and:[(currentClass isInterface)not])] whileTrue:  [		currentClass := currentClass superclass.		behavesSet addAll: currentClass behavesLike.	].behavesSet do: [:interf |	(self ~= interf) "for every interface different from me"	ifTrue: [		behavesSet addAll: interf behavesLike.		]	].^behavesSet."need to keep order!!!!!! TODO FIXXXXXXXXXXXXXXXXXXXXX"! !!MyObject class methodsFor: 'class methods' stamp: '4 12/25/2018 11:21'!compile: aSourceCode where: anOrderedCollection| s stream reg1 reg2 sFirstLine sSecLine sSecLine2 sInjected sCode args typeCheck abstract |stream := aSourceCode readStream.sFirstLine := String new.sFirstLine := stream nextLine. "first line - function name+ parameters"sSecLine := String new.sSecLine := stream nextLine. "second line - maybe local variables maybe firstline of code - and maybe EMPTY!!"abstract:= (self isAbstract: aSourceCode).((self isInterface) and:[abstract = false])"trying to compile not an abstract method to an Interface!!"	ifTrue:[AssertionFailure signal: 'Interfaces are not allowed to have methods that define behavior!!']."creating the local variables line"sSecLine2 := String new.reg1:= '.*\|.*' asRegex.((abstract == false) and:[reg1 matches: sSecLine]) "we already have local vars or abstract method"	ifTrue: [		sSecLine2 := '|', (sSecLine copyWithout: $| ), ' index currentClass |'.		sCode := (stream nextLine),Character cr.		[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]	ifFalse: [sSecLine2 := '| args restricts index currentClass |'.			(abstract == false) ifTrue: [sCode := sSecLine].			[stream atEnd] whileFalse: [sCode := sCode, (stream nextLine),Character cr].	]."getting the args from the function parameters"args := OrderedCollection new.reg1:= '\:(\s)*(\w)+' .reg2 := '\w+' .sFirstLine copyWithRegex: reg1 matchesTranslatedUsing: [:match |	match copyWithRegex: reg2 matchesTranslatedUsing: [:arg | args add: arg]]."check the size of the restriction and the arguments given"	(args size == anOrderedCollection size) 	ifFalse:[AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!']."here we know the sizes are equal"typeCheck := String new.typeCheck := '((true) '.(args size >= 1)ifTrue: [	((anOrderedCollection at:1) asString = 'nil')	ifFalse: [	typeCheck :=typeCheck, 'and:[currentClass:=''',(anOrderedCollection at:1),'''. ',(args at:1),' isKindOf: (',(anOrderedCollection at:1),')] '.]]. "first"2 to: (args size) do:	[:i | 			((anOrderedCollection at:i) asString = 'nil')			ifTrue: [typeCheck :=typeCheck, 'and:[index:= index+1. true] ']			ifFalse: [			typeCheck := typeCheck,'and:[index:= index+1. currentClass:=''',(anOrderedCollection at:i) ,'''. ',			(args at:i),' isKindOf: (',(anOrderedCollection at:i),')] '].].typeCheck := typeCheck,')',Character cr."now typeCheck is ((XXX) and:[XXX]"s:= String new.sInjected:= String new."creating injected code for checking"sInjected := 'index := 1.',Character cr.sInjected := sInjected, 'currentClass := String new.',Character cr.sInjected := sInjected,typeCheck,						'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument '', (index asString) , '' should be '', currentClass ].'.s:= sFirstLine,Character cr, sSecLine2,Character cr,	sInjected ,Character cr.	(abstract == false) ifTrue: [s:=s,sCode].	"Transcript show: s. REMOVEE!!!!!!"self compile: s.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 13:42'!isImplemented| subClasses isImplemented found  |(self isInterface)	ifFalse:[AssertionFailure signal: (self class name) asString, ' is not an interface!!'].subClasses := Set new.isImplemented:= false.subClasses:= (MyObject allSubclasses) asSet.subClasses do: [:subClass |found:= true. (((subClass behavesLike) includes: self) and: [(subClass isInterface) not])				ifTrue: [ "subclass behaves like given Interface"					(self methodDict size = 0)						ifTrue: [isImplemented:=true].					self methodDictionary keys do: [:method | "for each method in self"							(found and: [(subClass canUnderstand: method ) not]) 								ifTrue:[found := false]. "subclass doesnt understand this interface methods so go out!!"										].					(found)						ifTrue: [isImplemented:=true].					 ].			].^isImplemented.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/23/2018 20:53'!isInterface	^isInterface.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/25/2018 20:49'!new(self isInterface)	 ifTrue:[AssertionFailure signal: 'Interfaces can not be instantiated!!'].(self behavesLike) do:[:interface | 	((interface isImplemented)not) "check if all interfaces from behaveLike are implemented"		ifTrue:[AssertionFailure signal: 'Can not instantiate an Abstract class!!'].	].^ self basicNew initialize.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 13:15'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNam| newClass |newClass :=(ClassBuilder new)		superclass: self		subclass: aSubclassName		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries		category: aCategoryNam.		newClass instVarNamed: 'isInterface' put: false.newClass instVarNamed: 'behavesLike' put: {}. "(self behavesLike). "^newClass.! !!MyObject class methodsFor: 'class methods' stamp: '4 12/26/2018 13:45'!subclass: aSubclassName isInterface: isInterface behavesLike:aCollection instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryNa| newClass |(isInterface and:[(self class)asString ~= 'MyObject class']) 	ifTrue:[AssertionFailure signal: 'Interfaces must derive from MyObject!!'].	"'Interfaces can not have state!!'"(isInterface and:[instVarNames ~= '']) 	ifTrue:[AssertionFailure signal: 'Interfaces can not have state!!'].(isInterface == false and:[self isInterface])	ifTrue:[AssertionFailure signal: 'Classes can not derive from an interface!!'].aCollection do: [:c | (c isInterface) ifFalse:[AssertionFailure signal:'Can not behave like a non-interface!!'] ].newClass := self subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryNa."newClass addInstanceVarNamed: 'isInterface' withValue: isInterface.aSubclassName  addInstanceVarNamed: 'behavesLike' withValue: aCollection."newClass instVarNamed: 'isInterface' put: isInterface.newClass instVarNamed: 'behavesLike' put: (aCollection asSet).^newClass.! !!MyObject class methodsFor: 'Aux' stamp: '4 12/25/2018 11:13'!isAbstract: code| stream line1 line2 |stream := code readStream.line1 := String new.line2 := String new.line1 := stream nextLine. "first line - function name+ parameters"line2 := stream nextLine. "first line - function name+ parameters"(line2 = nil)	ifTrue:[^true].^false.! !MyObject subclass: #A	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!