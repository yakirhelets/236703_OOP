TestCase subclass: #SanityTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3SanityTests'!!SanityTests methodsFor: 'as yet unclassified' stamp: 'NB 12/11/2018 12:22'!setUpMyObject instVarNamed: 'isInterface' put: false.MyObject instVarNamed: 'behavesLike' put: {}.(Smalltalk hasClassNamed: #A) ifTrue: [Smalltalk removeClassNamed: #A].(Smalltalk hasClassNamed: #B) ifTrue: [Smalltalk removeClassNamed: #B].(Smalltalk hasClassNamed: #C) ifTrue: [Smalltalk removeClassNamed: #C].(Smalltalk hasClassNamed: #IA) ifTrue: [Smalltalk removeClassNamed: #IA].(Smalltalk hasClassNamed: #IB) ifTrue: [Smalltalk removeClassNamed: #IB].! !!SanityTests methodsFor: 'as yet unclassified' stamp: 'NB 12/11/2018 12:31'!testSanityPart1MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.A subclass: #B instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."compiling the old way"B compile:'foo'.self assert: (B methodDict size = 1)."compiling the new way:"B compile:'foo: a' where: #(Integer).self assert: (B methodDict size = 2).! !!SanityTests methodsFor: 'as yet unclassified' stamp: 'NB 12/11/2018 12:32'!testSanityPart2| flag |"compile 2 interfaces:"MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.MyObject subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.self assert: (IA isInterface = true).self assert: (IB isInterface = true)."compile a class using the old way:"MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.A subclass: #C instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."check that this class understands isInterface: and behavesLike: :"self assert: (A isInterface = false).self assert: (A behavesLike size = 0).self assert: (C isInterface = false).self assert: (C behavesLike size = 0)."compile a class using the new way:"MyObject subclass: #B isInterface: false behavesLike: {IA . IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.self assert: (B isInterface = false).self assert: (B behavesLike size = 2)."random error check, I chose 2, since it's a nice random number:"[MyObject subclass: #IStateful isInterface: true behavesLike: {} instanceVariableNames: 'should be empty' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Interfaces can not have state!!')	].self assert: (flag = true)! !!SanityTests methodsFor: 'as yet unclassified' stamp: 'NB 12/11/2018 12:35'!testSanityPart3|a|MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.MyObject subclass: #A isInterface: false behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.a := A new.self assert: (a isKindOf: IA).self assert: (a isKindOf: A).! !