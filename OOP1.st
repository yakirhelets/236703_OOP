Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'initialize-release' stamp: '4 11/7/2018 16:42'!initialize	exp := 0.	coef := 0.! !!Monom methodsFor: 'derivative' stamp: '4 11/7/2018 16:49'!derivative	| newMonom |	newMonom := Monom new.	(self exp >0)		ifTrue: [				newMonom exp: (self exp - 1).				newMonom coef: (self coef * self exp).				].	^newMonom.! !!Monom methodsFor: 'printing' stamp: '4 11/7/2018 17:45'!print 	Transcript show: (' ' ,self coef asString, 'X^' , self exp asString).! !!Monom methodsFor: 'setting' stamp: '4 11/7/2018 16:46'!coef: anInteger	(anInteger isInteger)	ifTrue: [			coef := anInteger.			]	ifFalse: [			self error: 'invalid input'.			]! !!Monom methodsFor: 'setting' stamp: '4 11/7/2018 16:45'!exp: anInteger	(anInteger isInteger and: [anInteger >= 0])	ifTrue: [			exp := anInteger.			]	ifFalse: [			self error: 'invalid input'.			]! !!Monom methodsFor: 'getting' stamp: '4 11/7/2018 16:45'!coef	^coef.! !!Monom methodsFor: 'getting' stamp: '4 11/7/2018 16:42'!exp	^exp.! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'setting' stamp: '4 11/10/2018 12:47'!add: aPolyStream	(aPolyStream isKindOf: PolyStream)	ifTrue: [			| oldBlock newBlock |			oldBlock := self block. 			"save the old block"			newBlock := aPolyStream block. "save the new block"			block := [ 						"update the block accord."					|polynom newPoly| 					polynom := Dictionary new.					newPoly := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					newPoly addAll: (newBlock value). "the 'recursive call' - here we evaluate the newBlock"					"here we checking for same exp in both of the polyStreams"					polynom keysAndValuesDo: [:exp :coef |						newPoly at:exp ifPresent: [:newCoef | polynom at: exp put: (newCoef + coef)]].					"now we enumarete on the unique exp in the second polystream:"					newPoly keysAndValuesDo: [:exp :coef | 						polynom at:exp 						 ifAbsent: [polynom at:exp put: coef] "add new 'monoms' from the new poly"												].					polynom. "the 'updated' polynom is here for future evaluation"					].				]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'setting' stamp: '4 11/7/2018 18:42'!addCoef: coef withExp: exp	((exp isInteger) and:[coef isInteger] and: [exp >= 0])	ifTrue: [			| oldBlock |			oldBlock := self block. "save the old block"			block := [ "update the block accord."					|polynom| 					polynom := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					polynom at:exp ifPresent: [:oldCoef | polynom at: exp put: (oldCoef + coef)]									ifAbsent: [polynom at:exp put: coef].					polynom. "the 'updated' polynom is here for future evaluation"					]			]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'setting' stamp: '4 11/10/2018 13:14'!filter: aSet	(aSet isKindOf: Set)	ifTrue: [			| oldBlock  setCopy |			oldBlock := self block. "save the old block"			setCopy := Set new.			setCopy := aSet deepCopy. "creating a deepCopy so future changes won't effect filter"			block := [ "update the block accord."					| polynom | 					polynom := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					setCopy do: [:key | polynom removeKey: key ifAbsent:[] ].					polynom. "the 'updated' polynom is here for future evaluation"					]				]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'setting' stamp: '4 11/7/2018 19:03'!multiplyBy: anInteger	(anInteger isInteger)	ifTrue: [			| oldBlock |			oldBlock := self block. "save the old block"			block := [ "update the block accord."					|polynom| 					polynom := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					polynom keysAndValuesDo: [:exp :coef |						 polynom at: exp put: (coef * anInteger)].					polynom. "the 'updated' polynom is here for future evaluation"					]			]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'setting' stamp: '4 11/7/2018 19:03'!substitute: anInteger	(anInteger isInteger and: [anInteger ~= 0])	ifTrue: [			| oldBlock |			oldBlock := self block. "save the old block"			block := [ "update the block accord."					|polynom| 					polynom := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					polynom keysAndValuesDo: [:exp :coef |						 polynom at: exp put: (coef * (anInteger raisedTo: exp))].					polynom. "the 'updated' polynom is here for future evaluation"					]			]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'initialize-release' stamp: '4 11/7/2018 18:13'!initialize	| polynom |	polynom := Dictionary new.	polynom at: 0 put: 0.	block := [polynom].! !!PolyStream methodsFor: 'getting' stamp: '4 11/7/2018 18:13'!block	^block.! !!PolyStream methodsFor: 'getting' stamp: '4 11/9/2018 21:36'!eval: anInteger	(anInteger isInteger)	ifTrue: [			| result |			result := 0.			"evaluation is done outside the block -> here the recursion really starts"			(self block value) keysAndValuesDo: [:exp :coef | 				 result := result + (coef * (anInteger raisedTo: exp))].			^result.			]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'getting' stamp: 'YH 11/11/2018 20:02'!intersectionWith: aPolyStream withinRange: anInteger willUpdate: aBoolean	"need to address willUpdate + testing"	(aPolyStream isKindOf: PolyStream and: anInteger isInteger)	ifTrue: [			| oldBlock newBlock x|			oldBlock := self block. 			"save the old block"			newBlock := aPolyStream block. "save the new block"			x := 0.			block := [ 						"update the block accord."					|polynom newPoly| "x is our guess num" 					polynom := Dictionary new.					newPoly := Dictionary new.					((x<anInteger) or: (x>anInteger))					ifTrue: [						self error: 'out of bounds'. "x is out of the range's bounds"						]					ifFalse: [						polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"						newPoly addAll: (newBlock value). "the 'recursive call' - here we evaluate the newBlock"						"here we checking for same exp in both of the polyStreams"						(polynom eval: x == newPoly eval: x)						ifTrue: [							^x.							]						ifFalse: [							(x<0)							ifTrue: [								x := (x*(-1))+1.								Transcript show: 'wait for it...' printString.								]							ifFalse: [								x := x*(-1).								Transcript show: 'wait for it...' printString.								]							]						polynom. "the 'updated' polynom is here for future evaluation"						]										].				]	ifFalse: [		self error: 'invalid input'.			]	.! !!PolyStream methodsFor: 'printing' stamp: '4 11/10/2018 12:32'!print		Transcript show: (self block value) .! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'initialize-release' stamp: '4 11/10/2018 11:54'!initialize	"Polynom is a Set of Monoms"	monoms := Set new. ! !!Polynom methodsFor: 'getting' stamp: '4 11/7/2018 17:49'!asDictionary	| newDict |	newDict := Dictionary new.	monoms do: [:monom | newDict at: (monom exp) put: (monom coef)].	^newDict.! !!Polynom methodsFor: 'getting' stamp: '4 11/7/2018 17:52'!derivative	| newPoly |	newPoly := Polynom new.	monoms do: [:monom | newPoly addMonom: (monom derivative)].	^newPoly.! !!Polynom methodsFor: 'getting' stamp: '4 11/7/2018 17:57'!eval: anInteger	(anInteger isInteger)	ifTrue: [			| value |			value := 0.			monoms do: [:monom | value := value + (monom coef * (anInteger raisedTo: (monom exp)))].			^value.			]	ifFalse: [			self error: 'invalid input'.			]! !!Polynom methodsFor: 'adding' stamp: '4 11/7/2018 18:03'!add: aPolynom	(aPolynom isKindOf: Polynom)	ifTrue: [			| newPoly |			newPoly := Polynom new.			monoms do: [:monom | newPoly addMonom: monom ].			aPolynom do: [:monom2 | newPoly addMonom: monom2 ].			^newPoly.			]	ifFalse: [		self error: 'invalid input'.			]! !!Polynom methodsFor: 'adding' stamp: '4 11/10/2018 11:56'!addMonom: aMonom	(aMonom isKindOf: Monom)	ifTrue: [			| expList newMonom |				expList := Set new.				monoms do: [:monom | expList add: (monom exp)]. "saving all current exps"				(expList includes: (aMonom exp)) " check if we already have this exp"				ifTrue: [					monoms do: [:monom | (monom exp = aMonom exp) "change the coef accord."						ifTrue: [							monom coef: (monom coef + aMonom coef)								]						]					]				ifFalse: [ "we dont have this exp yet"					      newMonom := Monom new.						newMonom exp: (aMonom exp).						newMonom coef: (aMonom coef).						monoms add: newMonom.						].	monoms := monoms reject: [:monom | (monom coef) =0]. "delete all the monoms with coef=0"				]	ifFalse: [		self error: 'invalid input'.			]! !!Polynom methodsFor: 'multiply' stamp: '4 11/7/2018 17:44'!multiplyByMonom: aMonom	(aMonom isKindOf: Monom)	ifTrue: [			((aMonom coef) = 0)			ifTrue: [					monoms := Set new.					^self.				].			monoms do: [:monom | monom coef: ((monom coef) * (aMonom coef)).				monom exp: ((monom exp) + (aMonom exp)) ]			]	ifFalse: [		self error: 'invalid input'.			]! !!Polynom methodsFor: 'do' stamp: '4 11/7/2018 18:04'!do: aBlock	monoms do: aBlock.! !!Polynom methodsFor: 'printing' stamp: '4 11/7/2018 17:30'!print 	monoms do: [:monom | monom print].! !