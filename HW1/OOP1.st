Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'initialize-release' stamp: '4 11/7/2018 16:42'!initialize	exp := 0.	coef := 0.! !!Monom methodsFor: 'derivative' stamp: '4 11/7/2018 16:49'!derivative	| newMonom |	newMonom := Monom new.	(self exp >0)		ifTrue: [				newMonom exp: (self exp - 1).				newMonom coef: (self coef * self exp).				].	^newMonom.! !!Monom methodsFor: 'printing' stamp: '4 11/7/2018 17:45'!print 	Transcript show: (' ' ,self coef asString, 'X^' , self exp asString).! !!Monom methodsFor: 'setting' stamp: '4 11/7/2018 16:46'!coef: anInteger	(anInteger isInteger)	ifTrue: [			coef := anInteger.			]	ifFalse: [			self error: 'invalid input'.			]! !!Monom methodsFor: 'setting' stamp: '4 11/7/2018 16:45'!exp: anInteger	(anInteger isInteger and: [anInteger >= 0])	ifTrue: [			exp := anInteger.			]	ifFalse: [			self error: 'invalid input'.			]! !!Monom methodsFor: 'getting' stamp: '4 11/7/2018 16:45'!coef	^coef.! !!Monom methodsFor: 'getting' stamp: '4 11/7/2018 16:42'!exp	^exp.! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'printing' stamp: '4 11/10/2018 12:32'!print		Transcript show: (self block value) .! !!PolyStream methodsFor: 'setting' stamp: '4 11/10/2018 12:47'!add: aPolyStream	(aPolyStream isKindOf: PolyStream)	ifTrue: [			| oldBlock newBlock |			oldBlock := self block. 			"save the old block"			newBlock := aPolyStream block. "save the new block"			block := [ 						"update the block accord."					|polynom newPoly| 					polynom := Dictionary new.					newPoly := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					newPoly addAll: (newBlock value). "the 'recursive call' - here we evaluate the newBlock"					"here we checking for same exp in both of the polyStreams"					polynom keysAndValuesDo: [:exp :coef |						newPoly at:exp ifPresent: [:newCoef | polynom at: exp put: (newCoef + coef)]].					"now we enumarete on the unique exp in the second polystream:"					newPoly keysAndValuesDo: [:exp :coef | 						polynom at:exp 						 ifAbsent: [polynom at:exp put: coef] "add new 'monoms' from the new poly"												].					polynom. "the 'updated' polynom is here for future evaluation"					].				]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'setting' stamp: '4 11/7/2018 18:42'!addCoef: coef withExp: exp	((exp isInteger) and:[coef isInteger] and: [exp >= 0])	ifTrue: [			| oldBlock |			oldBlock := self block. "save the old block"			block := [ "update the block accord."					|polynom| 					polynom := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					polynom at:exp ifPresent: [:oldCoef | polynom at: exp put: (oldCoef + coef)]									ifAbsent: [polynom at:exp put: coef].					polynom. "the 'updated' polynom is here for future evaluation"					]			]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'setting' stamp: '4 11/10/2018 13:14'!filter: aSet	(aSet isKindOf: Set)	ifTrue: [			| oldBlock  setCopy |			oldBlock := self block. "save the old block"			setCopy := Set new.			setCopy := aSet deepCopy. "creating a deepCopy so future changes won't effect filter"			block := [ "update the block accord."					| polynom | 					polynom := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					setCopy do: [:key | polynom removeKey: key ifAbsent:[] ].					polynom. "the 'updated' polynom is here for future evaluation"					]				]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'setting' stamp: '4 11/7/2018 19:03'!multiplyBy: anInteger	(anInteger isInteger)	ifTrue: [			| oldBlock |			oldBlock := self block. "save the old block"			block := [ "update the block accord."					|polynom| 					polynom := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					polynom keysAndValuesDo: [:exp :coef |						 polynom at: exp put: (coef * anInteger)].					polynom. "the 'updated' polynom is here for future evaluation"					]			]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'setting' stamp: '4 11/7/2018 19:03'!substitute: anInteger	(anInteger isInteger and: [anInteger ~= 0])	ifTrue: [			| oldBlock |			oldBlock := self block. "save the old block"			block := [ "update the block accord."					|polynom| 					polynom := Dictionary new.					polynom addAll: (oldBlock value). "the 'recursive call' - here we evaluate the oldBlock"					polynom keysAndValuesDo: [:exp :coef |						 polynom at: exp put: (coef * (anInteger raisedTo: exp))].					polynom. "the 'updated' polynom is here for future evaluation"					]			]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'initialize-release' stamp: '4 11/12/2018 21:51'!initialize	| polynom |	polynom := Dictionary new.	block := [polynom at: 0 put: 0. polynom].! !!PolyStream methodsFor: 'getting' stamp: '4 11/7/2018 18:13'!block	^block.! !!PolyStream methodsFor: 'getting' stamp: '4 11/12/2018 21:19'!eval: anInteger	(anInteger isInteger)	ifTrue: [			| result |			result := 0.			"evaluation is done outside the block -> here the recursion really starts"			((self block) value) keysAndValuesDo: [:exp :coef | 				 result := result + (coef * (anInteger raisedTo: exp))].			^result.			]	ifFalse: [		self error: 'invalid input'.			]! !!PolyStream methodsFor: 'getting' stamp: '4 11/12/2018 20:53'!guessBlock	| guess guessB |	guess :=0. "initial value for guess"	guessB := [				| newGuess |				newGuess := guess.				(guess <=0) "updates the next guess val accord."				ifTrue: [						guess := guess * (-1) + 1.						]				ifFalse: [						guess := guess * (-1).						].				newGuess.			].		^guessB.! !!PolyStream methodsFor: 'getting' stamp: '4 11/13/2018 10:44'!intersectionWith: aPolyStream withinRange: anInteger willUpdate: aBoolean	(anInteger isInteger and: [aPolyStream isKindOf: PolyStream])	"works for will update=true, for false we need to make a local copy of the polyStream"	ifTrue: [			| guessB newBlock poly1 poly2 |			(aBoolean  = false) "check will update variable"			ifTrue: [					poly1 := PolyStream new.					poly2 := PolyStream new.					poly1 := self copy.					poly2 := aPolyStream copy.					].			guessB := (self guessBlock).			newBlock := [				| currentGuess result obj1 obj2 |				obj1 := self.				obj2 := aPolyStream.				(aBoolean  = false) "here we choose if we reffer to the copy or the updated block "				ifTrue: [					obj1 := poly1.					obj2 := poly2.						].				currentGuess := (guessB value). "getting current guess from guessB"				(currentGuess > anInteger)				ifTrue: [					self error: 'invalid input'. "out of range"					]				ifFalse: [ 					((obj2 eval: currentGuess) == (obj1 eval: currentGuess))					ifTrue: [							result := currentGuess.							]					ifFalse: [							result := 'wait for it...'.							]						].					result. "local return for the current result"					].				^newBlock. "returns the evaluation block!!"			]	ifFalse: [			self error: 'invalid input'.			]! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'initialize-release' stamp: '4 11/10/2018 11:54'!initialize	"Polynom is a Set of Monoms"	monoms := Set new. ! !!Polynom methodsFor: 'getting' stamp: '4 11/7/2018 17:49'!asDictionary	| newDict |	newDict := Dictionary new.	monoms do: [:monom | newDict at: (monom exp) put: (monom coef)].	^newDict.! !!Polynom methodsFor: 'getting' stamp: '4 11/7/2018 17:52'!derivative	| newPoly |	newPoly := Polynom new.	monoms do: [:monom | newPoly addMonom: (monom derivative)].	^newPoly.! !!Polynom methodsFor: 'getting' stamp: '4 11/7/2018 17:57'!eval: anInteger	(anInteger isInteger)	ifTrue: [			| value |			value := 0.			monoms do: [:monom | value := value + (monom coef * (anInteger raisedTo: (monom exp)))].			^value.			]	ifFalse: [			self error: 'invalid input'.			]! !!Polynom methodsFor: 'adding' stamp: '4 11/7/2018 18:03'!add: aPolynom	(aPolynom isKindOf: Polynom)	ifTrue: [			| newPoly |			newPoly := Polynom new.			monoms do: [:monom | newPoly addMonom: monom ].			aPolynom do: [:monom2 | newPoly addMonom: monom2 ].			^newPoly.			]	ifFalse: [		self error: 'invalid input'.			]! !!Polynom methodsFor: 'adding' stamp: '4 11/10/2018 11:56'!addMonom: aMonom	(aMonom isKindOf: Monom)	ifTrue: [			| expList newMonom |				expList := Set new.				monoms do: [:monom | expList add: (monom exp)]. "saving all current exps"				(expList includes: (aMonom exp)) " check if we already have this exp"				ifTrue: [					monoms do: [:monom | (monom exp = aMonom exp) "change the coef accord."						ifTrue: [							monom coef: (monom coef + aMonom coef)								]						]					]				ifFalse: [ "we dont have this exp yet"					      newMonom := Monom new.						newMonom exp: (aMonom exp).						newMonom coef: (aMonom coef).						monoms add: newMonom.						].	monoms := monoms reject: [:monom | (monom coef) =0]. "delete all the monoms with coef=0"				]	ifFalse: [		self error: 'invalid input'.			]! !!Polynom methodsFor: 'multiply' stamp: '4 11/7/2018 17:44'!multiplyByMonom: aMonom	(aMonom isKindOf: Monom)	ifTrue: [			((aMonom coef) = 0)			ifTrue: [					monoms := Set new.					^self.				].			monoms do: [:monom | monom coef: ((monom coef) * (aMonom coef)).				monom exp: ((monom exp) + (aMonom exp)) ]			]	ifFalse: [		self error: 'invalid input'.			]! !!Polynom methodsFor: 'do' stamp: '4 11/7/2018 18:04'!do: aBlock	monoms do: aBlock.! !!Polynom methodsFor: 'printing' stamp: '4 11/7/2018 17:30'!print 	monoms do: [:monom | monom print].! !